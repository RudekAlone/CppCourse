# 3.2.3 Tic-Tac-toe i obsługa plików
W poprzednich dwóch lekcjach przedstawiłem Ci podstawowe założenia programowania zorientowanego obiektowo. Teraz w ramach utrwalenia tej wiedzy wykonamy program konsolowy mini gry *Tic-Tac-Toe* czyli *Kółko i krzyżyk* z obsługą komunikatów wielojęzycznych, które będą wczytywane z odpowiednich plików tekstowych.

## Menu wyboru

W metodzie `int main()` napiszemy proste menu z trzema opcjami:
- __Play__ - Do uruchomienia gry.
- __Language__ - Do zmiany języka.
- __Exit__ - Do zakończenia pracy programu konsolowego.

Przykładowy kod może wyglądać w następujący sposób:

<small>main.cpp</small>

```cpp
#include <iostream>

int main()
{
	short choiceMenu;

	// Menu do wyświetlenia:
	std::cout << "Tic-Tac-Toe!\n\n"
                << "1. Play\n"
                << "2. Language\n"
                << "3. Exit\n" << std::endl;

	while (true) {
		std::cout << "Enter your choice: ";
		std::cin >> choiceMenu;

		// Wybór opcji:
		switch (choiceMenu)
		{
		case 1:
			std::cout << "Play" << std::endl;
			break;
		case 2:
			std::cout << "Language" << std::endl;
			break;
		case 3:
			return 0;
		default:
			std::cout << "Invalid choice. Please enter a number between 1 and 3."<< std::endl;
		}
	}
	return 0;
}
```

Wykorzystujemy bibliotek STL `<iostream>` do obsługi strumienia wejścia wyjścia konsoli naszego programu.  

Interakcja z programem bedzie ograniczona do wprowadzania liczb przez użytkownika, a biorąc pod uwagę aspekt optymalizacyjny zakładamy że podawane wartości nie będą wieksze niż 2 Bajty i zawsze podawana bedzie liczba wiec można wykorzystać zamiast `int`, zmienną całkowito-liczbową o typie `short`/`short int` którego zakres wartości to $$-32\phantom{0}768$$ do $$32\phantom{0}767$$.  

Następnie wykorzystując `std::cout` wypisuję tytuł programu z dopiskiem `\n` który przechodzi do nowej lini i na koniec przy pomocy `std::endl` znowu jest przejście do nowej lini oraz wyczyszczenie bufora. Zapisanie elementów menu w jednym `std::cout` jest lepsze niż wywoływanie go dla każdej linii ponieważ ograniczasz ilość operacji wejścia/wyjścia do jednej niezależnie od ilości dostępnych opcji.  

Ostatnią częścią naszego menu jest `switch` który na podstawie wartości liczbowej z `choiceMenu` wykona odpowiedni fragment kodu. ( Zwróć uwagę że nie ma wartości default gdyż w tym kodzie nigdy nie został by wykonany bo fragment z pętlą `while` gwarantuje poprawność wprowadzonej wartości do `choiceMenu`)

### Analiza problemowa kodu "Menu wyboru" w main.cpp

Zobacz co się stanie gdy po uruchomieniu aktualnego kodu wprowadzisz wartość nie liczbową np.: literę albo znak. Aby temu zapobiec musimy dopisać fragment kodu, który bedzie odpowiedzialny za walidację wprowadzonych wartości przez użytkownika.  

Napiszemy funkcję `boolean` zwracającą `true`/`false` w zależności czy podana wartość w pełni składa się z cyfr.
W przypadku wprowadzenia __"1s2"__ zostanie zwrócony fałsz adekwatnie dla wprowadzenia __"/h$2"__.  
Jak już widzisz funkcja powinna przyjmować wartość w zmiennej typu `std::string` i z pomocą pętli sprawdzić poprawność każdego znaku w tym ciągu, czyli potraktujemy string jako tablicę znaków - `char[]`. Biblioteka __STL__ udostępnia nam przyjemną metodę do sprawdzenia czy znak jest cyfrą: `std::isdigit(char znak)`.

```cpp
bool isNumber(std::string str) {
	for (char c : str) {
		if (!std::isdigit(c)) return false;
	}
	return true;
}
```
Nie zapomnij dodać biblioteki `<string>`:

```cpp
#include <string>
```
Sprawdźmy teraz czy metoda działa poprawnie dla wartości nie składających się wyłącznie z cyfr:

```cpp
// początek metody: int main(){
std::string choice;
short choiceMenu = 0;

std::cin >> choice;// ręczne wprowadzenie wartości testowych
std::cout << isNumber(choice) << std::endl; // zwraca 1 jeżeli podano wartość liczbową lub zero gdy wprowadzono jakikolwiek znak nie będący cyfrą 

return 0; // zwrócenie 0 i nie wywołanie późniejszego kodu w int main()

// reszta kody ...
// zakończenie main`a: }

```

Jak wszystko działa poprawnie to dokonajmy kolejnej poprawki w kodzie. Możemy walidację wprowadzonej wartości wyseparować przed wywołaniem wyboru w switch'u. Dzieki czemu napisany kod bedzie czytelniejszy i podzielimy funkcjonalności na osobne fragmenty kodu. Dodatkowo dzieki uprzedniej walidacji wprowadzonej wartości nie potrzebujemy już `default` w `switch()`:

```cpp
#include <iostream>
#include <string>

bool isNumber(std::string str) {
	for (char c : str) {
		if (!std::isdigit(c)) return false;
	}
	return true;
}

int main()
{
	std::string choice;
	short choiceMenu = 0;

	// Menu do wyświetlenia:
	std::cout << "Tic-Tac-Toe!\n\n"
		<< "1. Play\n"
		<< "2. Language\n"
		<< "3. Exit\n" << std::endl;

	// Ciągła walidacja wyboru:
	while (true) {
		std::cout << "Enter your choice: ";
		std::cin >> choice;

		// Sprawdzenie poprawności wyboru:
		if (isNumber(choice)) {
			choiceMenu = std::stoi(choice);
			if (choiceMenu >= 1 && choiceMenu <= 3) {
				break; // Wyjście z pętli gdy wybór jest poprawny i w zakresie
			}
		}

		// Wyświetlenie komunikatu o błędzie gdy oba warunki if nie są spełnione:
		std::cout << "Invalid choice. Please enter a number between 1 and 3." << std::endl;
	}

	// Wywołanie odpowiedniego case`a w zależności od wyboru:
	switch (choiceMenu)
	{
	case 1:
		std::cout << "Play" << std::endl;
		break;
	case 2:
		std::cout << "Language" << std::endl;
		break;
	case 3:
		return 0;
	}

	return 0;
}
``` 

## Obsługa plików i wybór języka komunikatów

Przygotujmy teraz klasę której przyznamy odpowiedzialność za wczytanie odpowiedniego pliku językowego komunikatów i udostępnianiu ich dla pozostałych obiektów.

Jak do tąd pisaliśmy programy jedno plikowe w `main.cpp` teraz czas przejść na wyższy poziom i wydzielić kod danych klas do oddzielnych plików:
- Plik nagłówkowy o rozszerzeniu `.h` bedzie przechowywał konstrukcję klasy.
- Plik implementacyj o rozszerzeniu `.cpp bedzie przechowywał implementację zadeklarowanych metod w nagłówku.

### Poprawa kodowania znaków specjalnych

Jak już pewnie zauważyłeś podczas wypisywania polskich znaków konsola wyświetlała jakieś dziwne wartości. Jest to spowodowane domyślnym kodowaniem `CP 1250` dla __CMD__ w Windowsie, które nie obsługuje wszystkich znaków specjalnych w różnych językach. Rozwiązaniem tego problemu jest zastosowanie metody do ustawienia kodowania w `UTF-8`:

```cpp
#include <Windows.h>
////
	SetConsoleOutputCP(CP_UTF8); // Ustawia kodowanie wyjścia na UTF-8
	SetConsoleCP(CP_UTF8);       // Ustawia kodowanie wejścia na UTF-8
///
```
PS.: Zwróć uwagę że twoje pliki z kodem w VS 2022 nie są zapisywane w `UTF-8` i testując poniższy fragment kodu nie uzyskasz poprawnie wypisanych wartości. No i w sumie to dobrze gdyż kod powinien być zapisywany w języku angielskim a wszelka translacja komunikatów dla użytkowników wyseparowana do plików zewnętrznych.

```cpp
 std::cout << "Zażółć gęślą jaźń" << std::endl; // Polski
 std::cout << "Überstraße" << std::endl;        // Niemiecki
 std::cout << "Привет, мир!" << std::endl;      // Rosyjski
```


### Analiza i tworzenie struktury klasy "Language"

Funkcjonalności klasy "Language":
- Ustawienie kodowania znaków wejścia i wyjścia konsoli na `UTF-8`.
- Menu wyboru języka.
- Załadowanie komunikatów językowych z odpowiedniego pliku tekstowego znajdującego się w katalogu "Language/".
- Przechowywanie komunikatów w zmiennej i zwolnienie dostępu do wczytanego pliku.
- Publiczne udostępnienie metody zwracającej treść komunikatu 

W pliki nagłówkowe dodaj nowy element `Language.h` którego podstawowa struktura to jedynie zapis `#pragma once` - zabezpieczający przed wielokrotnym dołączeniem pliku nagłówkowego.  
W pliki źródłowe dodaj nowy element `Language.cpp` który bedzie pusty.

Mając te dwa pliki zapiszemy strukturę klasy "Language" w nagłówku dołączając w nim potrzebne biblioteki. Deklarując zmienne o zasięgu klasowym, konstruktor z zawartością inicjalizacyjną oraz metody, których zawartość czyli implementację zawrzemy w `Language.cpp` ale to za chwilę.

Oto struktura nagłówka klasy `Language` z wszystkimi deklaracjami:

<small>Language.h</small>

```cpp
#pragma once // Zabezpieczenie przed wielokrotnym dołączaniem pliku nagłówkowego

// Dołączenie bibliotek standardowych
#include <iostream> // Strumienie wejścia/wyjścia
#include <string> // Obsługa łańcuchów znaków
#include <array> // Tablice o stałym rozmiarze
#include <Windows.h> // Obsługa funkcji Windows API z języka C które mogą być używane w C++

// Deklaracja tablicy z komunikatami
extern std::array<std::string, 10> messages;
// Pozwala na wczytanie maksymalnie 10 lini z pliku i chcąc więcej trzeba zwiększyć rozmiar tablicy
// Alternatywnie można użyć std::vector<std::string> messages; dla dynamicznego rozmiaru tablicy
// ale wtedy trzeba by było zmienić sposób wczytywania pliku

class Language
{
// Zmienne prywatne:
private:
	std::string langCode; // Kod języka który bedzie też nazwą pliku

// Metody publiczne:
public:
	Language(); // Konstruktor
	~Language(); // Destruktor

	// Wyświetla menu wyboru języka
	void selectLanguageMenu();
	// Metoda Getera zwracająca komunikat z tablicy na podstawie indeksu
	std::string getMessage(int index);

// Metody prywatne:
private:
	// Ustawia kodowanie konsoli na UTF-8
	void setConsoleEncoding();
	// Wczytuje plik z komunikatami
	void loadLanguageFile(std::string langCode);
}; // <== pamiętaj o średniku na koniec klamry klasy
```

<div data-hint="info">

__*Zauważyłeś słówko `extern` przy tablicy `messages`?*__  

To taki znak dla kompilatora: __"Hej, ta zmienna istnieje, ale nie tworzę jej tutaj – znajdziesz ją w pliku .cpp!"__.   
Dzięki temu będziemy mieć jedną wspólną tablicę `messages` dla wszystkich instancji obiektów klasy `Language`, a nie osobne kopie w każdym pliku. Gdyby `messages` zostało zadeklarowane tak jak `langCode` bezpośrednio w nagłówku to implementacja `Language.cpp` i `int main()` dostały by osobne kopie tej zmiennej.  

__*Jakie są z tego korzyści?*__
- Oszczedzamy pamięć bo w całym programie istnieje tylko jedna instancja zmiennej `messages`.
- Oszczedzamy czas i moc obliczeniową ograniczając liczbę otwarcia, wczytania i zamkniecia pliku z komunikatami językowymi do jednego.
- Wczytując daną wersję językową mamy pewność że nagle nie zmieni nam się język komunikatów w programie.

</div>

Implementacja zadeklarowanych metod bedzie zapisana w pliku `Language.cpp`

W Visual Studio 2022 możesz automatycznie tworzyć definicje zadeklarowanych metod w zależności od dostępu: 
- __Implementacja metod publicznych__: stworzy się w tym samym pliku nagłówkowym:

	![Generowanie definicji metody publicznej w pliku nagłówkowym](/Images/vs2022_define_in_h.png)

- __Implementacja metod prywatnych__: stworzy się w pliku implementacyjnym:

	![Generowanie definicji metody publicznej w pliku implementacyjnym](/Images/vs2022_define_in_cpp.png)

<div data-hint="warning">

Pomimo tego że Visual Studio 2022 proponuje zapis implementacji w pliku nagłówkowym  lepiej zawrzeć wszelką implementację włącznie z konstruktorem i destruktorem w pliku `NazwaKlasy.cpp`

</div>

Proponuję następującą strukturę pliku implementacyjnego `Language.cpp` gdzie na początku dodajemy nagłówek z strukturą klasy `"Language.h"` następnie konstruktor i destruktor.  
Metody możemy rozłożyć wzgledem dostępu publicznego i prywatnego:
```cpp

//
// PUBLIC METHODS
//
...

//
// PRIVATE METHODS
//
...
```

Przykładowa struktura implementacji klasy `Language` może być następująca:  
*(Pamiętaj, deklarowano w nagłówku że pojawi się tu zmienna `messages`!)*

<small>Language.cpp</small>

```cpp
#include "Language.h"

// Zdefiniowanie tablicy z komunikatami którą zadeklarowano w pliku nagłówkowym
std::array<std::string, 10> messages;


Language::Language()
{
	// kod
}

Language::~Language()
{
	// kod
}

//
// PRIVATE METHODS
//
void Language::setConsoleEncoding() 
{
	// kod
}

void Language::loadLanguageFile(std::string langCode)
{
	// kod
}

//
// PUBLIC METHODS
//
void Language::selectLanguageMenu()
{
}

std::string Language::getMessage(int index)
{
	// kod
}
```

Zapis: `NazwaKlasy::NazwaMetody` przy implementacji metod w C++ jest konieczny do:

- __Poprawnej kompilacji programu.__
	- Kompilator musi wiedzieć, do której klasy należy dana metoda, aby poprawnie zbudować program. Bez tego kompilator nie będzie w stanie powiązać deklaracji metody w pliku nagłówkowym z jej implementacją w pliku źródłowym.

- __Rozróżnienia metod należących do różnych klas.__
	- W dużych projektach może istnieć wiele klas, które mają metody o tych samych nazwach. Dopisanie `NazwaKlasy::NazwaMetody` pozwala na jednoznaczne określenie, do której klasy należy dana metoda.

- __Utrzymania czytelności i organizacji kodu.__
	- Dzięki temu kod jest bardziej czytelny i zorganizowany. Łatwiej jest zrozumieć, które metody należą do której klasy, zwłaszcza gdy implementacje są rozdzielone między różne pliki.


### Implementacja zadeklarowanych metod klasy "Language"


#### Konstruktor i destruktor

W konstruktorze można zawrzeć podstawowe wywołanie metod do ustawienia kodowania znaków w konsoli __CMD__ i załadowania domyślnie pliku z komunikatami po angielsku. Z racji zastosowania zmiennej messages jako statycznej warto zabezpieczyć się przed jej ponowną alokacją sprawdzając czy jest pusta: `messages.empty()`. Dzieki temu konstruktor wykona zawarte w nim instrukcje tylko przy pierwszym wywołaniu optymalizując w ten sposób działanie kodu.

Co do destruktora w prostych programach jego implementacja wydaje się zbędna ale ma sens dokumentacyjny, wskazując, że świadomie zdecydowałeś, iż nie ma żadnych zasobów do zwolnienia. Może to być pomocne dla innych programistów, którzy będą czytać Twój kod.

```cpp
// Implementacja konstruktora który, gdy zmienna statyczna messages jest pusta to:
// - ustawia domyślny język na angielski
// - ustawia kodowanie konsoli na UTF-8
// - wczytuje plik z komunikatami
Language::Language()
{
	if (messages[0] == "")
	{
		langCode = "en";
		setConsoleEncoding();
		loadLanguageFile(langCode);
    }
}
// Implementacja destruktora
Language::~Language()
{
	// Nie próbuj usuwać tablicy messages ponieważ jest ona statyczna i inne obiekty mogą z niej korzystać
}
```

#### Metody prywatne:

Ustawienie odpowiedniego kodowania znaków w konsoli __CMD__ programu.  
Wykorzystanie biblioteki `<Windows.h>`

```cpp
// Metoda ustawiająca kodowanie strumienia wejścia / wyjścia konsoli CMD na `UTF-8`
void Language::setConsoleEncoding() {
	SetConsoleOutputCP(CP_UTF8); // Ustawia kodowanie wyjścia na UTF-8
	SetConsoleCP(CP_UTF8);       // Ustawia kodowanie wejścia na UTF-8
}
```

Załadowanie zawartości pierwszej liczby lini nie wiekszej niż rozmiar tablicy do messages i zamkniecie dostępu do pliku gdy już nie bedzie się z niego korzystać.  
Zwraca komunikat błędu gdy nie uda się znaleźć i lub otworzyć pliku językowego.  
Wykorzystywanie biblioteki `<fstream>`

Dopisz do nagłówka `Language.h` z niezbędną dla tej metody biblioteką:

```cpp
#include <fstream> // Obsługa plików
```

```cpp
void Language::loadLanguageFile(std::string langCode)
{
	std::string line; // Zmienna pomocnicza do wczytywania linii z pliku
	std::ifstream file("Languages/" + langCode + ".txt"); // Strumień pliku z komunikatami
	if (file.is_open()) // Sprawdzenie czy plik został otwarty
    {
		// Pętla wczytująca linie z pliku do tablicy messages
        for (int i = 0; i < messages.size(); i++)
        {
			if (std::getline(file, line)) // Jeżeli udało się wczytać linię z pliku to zapisz ją do tablicy
            {
                messages[i] = line;
            }
            else
            {
				break; // Jeżeli nie udało się wczytać linii to przerwij pętlę
            }
        }
		// Zamknięcie pliku
        file.close();
    }
    else
    {
		// Komunikat o błędzie gdy nie udało się otworzyć pliku
        std::cerr << "Unable to open file: Languages/" << langCode << ".txt" << std::endl;
    }
}
```
#### Metody publiczne:

W metodzie `selectLanguageMenu()` bedziemy chcieli wyświetlić menu numeryczne podobnie tak jak zostało to zrobione w `int main()`. Pierwsza myśl która się nasuwa to skopiowanie i zmodyfikowanie już napisanego kodu. Taka praktyka jest niedopuszczalna! Skoro rozwiązaniem problemu miało by być zdublowanie kodu, to jest to czas na refaktoryzację całości.

Zastanówmy się nad nową klasą np.: `NumericMenu`. Jaką funkcjonalność musi spełniać aby udostępnić nam jako programiście prosty interfejs do re-używania.

Aktualnie w `int main()` mamy:
- Wyświetlenie menu za pomocą `std::cout`
- Funkcję sprawdzającą czy string skład się tylko z cyfr?
- Pętlę która prosi o wprowadzenie liczby odwołującej się do wyboru z menu i gdy wprowadzona wartość nie spełni założeń funkcji `isNumber(choice)` lub będzie spoza zakresu miedzy 1 a 3 to zwraca komunikat a pętla jest kontynuowana w innym przypadku wychodzi z pętli i wywołuje odpowiedni kod z switch`a.

Wiec struktura nagłówka może być następująca:

```cpp
#pragma once

#include <iostream>
#include <string>

class NumericInteraction
{
public:
	NumericInteraction();
	~NumericInteraction();
	
	// Sprawdza czy podany łańcuch znaków składa się tylko z cyfr
	bool isNumber(std::string str);
	// Ciągła walidacja wprowadzonego wyboru użytkownika w podanym zakresie
	short choiceOfRange(short min, short max);
};
```
Natomiast implementacja zadeklarowanych metod w `NumericInteraction` bedzie praktycznie bez zmian.  
(zamiast stosować bezpośrednio liczby 1 i 3 wykorzystywane są zmienne metody min i max)

```cpp
#include "NumericInteraction.h"

NumericInteraction::NumericInteraction()
{
}

NumericInteraction::~NumericInteraction()
{
}

//
// PUBLIC METHODS
//
bool NumericInteraction::isNumber(std::string str)
{
	for (char c : str) {
		if (!std::isdigit(c)) return false;
	}
	return true;
}

short NumericInteraction::choiceOfRange(short min, short max)
{
	std::string choice;
	short choiceMenu = 0;
	// Ciągła walidacja wyboru:
	while (true) {
		std::cout << "Enter your choice: ";
		std::cin >> choice;

		// Sprawdzenie poprawności wyboru:
		if (isNumber(choice)) {
			choiceMenu = std::stoi(choice);
			// !!!! UWAGA !!!! zastąpienie wartości 1 i 3 na min i max
			if (choiceMenu >= min && choiceMenu <= max) {
				break; // Wyjście z pętli gdy wybór jest poprawny i w zakresie
			}
		}

		// Wyświetlenie komunikatu o błędzie gdy oba warunki if nie są spełnione:
		std::cout << "Invalid choice. Please enter a number between " << min <<" and " << max << "." << std::endl;
		// Zmieniono zapis aby wykorzystywał zmienne min i max
	}

	return choiceMenu;
}
```
Teraz można uprościć zapisany kod w mian wykorzystując nowo utworzoną klasę `NumericInteraction` i zamknąć fragment kodu odpowiedzialnego za menu w nieskonczonej pętli z której wychodzimy gdy wywoła się w `switch` `cace`3:

```cpp
#include <iostream>
#include "NumericInteraction.h"
#include "Language.h"

int main()
{
	Language lang;
	NumericInteraction numericInter;

	while (true)
	{
		// Menu do wyświetlenia:
		std::cout << "Tic-Tac-Toe!\n\n"
			<< "1. Play\n"
			<< "2. Language\n"
			<< "3. Exit\n" << std::endl;

		// Wybór opcji z menu:
		short choiceMenu = numericInter.choiceOfRange(1, 3);

		// Wywołanie odpowiedniego case`a w zależności od wyboru:
		switch (choiceMenu)
		{
		case 1:
			std::cout << "Play" << std::endl;
			break;
		case 2:
			lang.selectLanguageMenu(); // Wywołanie metody wyboru języka
			break;
		case 3:
			return 0;
		}
	}
	return 0;
}
```

A wracając do implementacji metod w `Language.cpp` adekwatnie jak nowo zrefaktoryzowany kod `int main()` napiszemy metodę wyboru języka:

```cpp
void Language::selectLanguageMenu()
{
	std::cout << "Select language:\n\n"
		<< "1. English\n"
		<< "2. Polish\n"
		<< "3. German\n"
		<< "4. Russian\n"<< std::endl;
	short choice = NumericInteraction().choiceOfRange(1, 4);
	switch (choice)
	{
	case 1:
		langCode = "en";
		break;
	case 2:
		langCode = "pl";
		break;
	case 3:
		langCode = "de";
		break;
	case 4:
		langCode = "ru";
		break;
	}
	loadLanguageFile(langCode);
}
```
Metoda dostępu do wartości z zmiennej `messages` - Geter. Podejmująca próbę pobrania wartości z danego index'u i gdy bedzie spoza tablicy to rzuci wyjątkiem ktury obsłógujemyt w `catch` i wypisujemy za pomocą `std:cerr` komunikat o błędzie i zwracamy ciąg znaków: "Undefinited text" aby program w tym przypadku się nie wyłączył. Jest to dobra praktyka aby mimo napotkanych błędów zapewnić stabilność pisanego programu.

```cpp
std::string Language::getMessage(int index)
{
	try {
		return messages.at(index);
	}
	catch (const std::out_of_range exception) {
		std::cerr << "Out of range error: " << exception.what() << std::endl;
		return "Undefinited text";
	}
}
```




### Tłumaczenie komunikatów

Skoro mamy już w pełni przygotowaną klasę `Language` możemy zmodyfikować wszystkie wywołania komunikatów na ich odpowiedniki zgodne z wybranym językiem. Przygotujmy wiec plik tekstowy zawierający wszystkie użyte frazy.  
Przykład dla języka angielskiego reszte możesz przetłumaczyć używając np.: translatora od Google:

```txt
Tic-Tac-Toe!
1. Play
2. Language
3. Exit
Enter your choice: 
Invalid choice. Please enter a number between 
 and 
Select language:
1. English
2. Polish
3. German
4. Russian
```
Zobacz że plik ma 12 lini wiec bedzie trzeba zmienić rozmiar tablicy `messages` z 10 na 12.

<small>Language.h</small>

```cpp
extern std::array<std::string, 12> messages;
```
<small>Language.cpp</small>

```cpp
std::array<std::string, 12> messages;
```
Teraz zmodyfikuj wszystkiekomunikaty w kodzie programu odwołujące się do danych lini z plików.  
Przykładowo bedzie to wyglądać tak:

<small>main.cpp</small>

```cpp
// Menu do wyświetlenia:
std::cout << lang.getMessage(0)+ "\n\n"
	<< lang.getMessage(1) + "\n"
	<< lang.getMessage(2) + "\n"
	<< lang.getMessage(3) + "\n" << std::endl;
```



Zauważ że wywołuję na instancji metodę getera i za pomocą `+` dokonuję tak zwanej konkatenacji znaków doklejając znaki nowej lini: `\n\n`.

## Spaghetti code!!!

__*Spaghetti code? O co chodzi?*__  
Tak nazywana w środowisku programistów jest sytuacja kiedy pomiedzy metodami lub klasami stwierdzi się zbyt dużą zależność.  
W naszym programie klasy `Language` i `NumericInteraction` wykorzystują do zrealizowania działania swoich metod metody drugiego.  
Pojawia się to w przypadku gdy podczas walidacji wyboru postanowiliśmy wykorzystać metodę `getMessage(int index)` aby zwracać komunikaty w odpowiednim języku.
1. __Cykliczna zależność:__
	- `Language.h` inkluduje `NumericInteraction.h` (bo `selectLanguageMenu()` używa `NumericInteraction`).
	- `NumericInteraction.cpp` inkluduje `Language.h` (bo `choiceOfRange()` używa `Language` do komunikatów).
	Tworzy się wtedy następujący cykl:  
	`Language.h` ==> `NumericInteraction.h` ==> `Language.h`.
2. __Zagnieżdżenie obiektów:__
	- W `NumericInteraction::choiceOfRange()` tworzysz obiekt `Language lang`, żeby pobrać komunikaty (np. `lang.getMessage(4)`).
    - W `Language::selectLanguageMenu()` tworzysz obiekt `NumericInteraction`, żeby zwalidować wybór języka.
    To oznacza, że obie klasy są od siebie zależne i nie mogą istnieć samodzielnie.

Poniżej przedstawiam podgląd graficzny naszej sytuacji:

![Spaghetti code w Tic-Tac-Toe](/Images/Spaghetti_code_Tic-Tac-Toe.png)


Aby zerwać zależność cykliczną miedzy klasami i kontynuować pracę z projektem w którym nie występuje __Spaghetti Code__ przemyślmy jego strukturę i relacje.

Przeanalizujmy najpierw klasę `Language`:

1. Ustawia kodowanie znaków w konsoli na __UTF-8__
2. Ładuje treść komunikatów z odpowiedniego pliku językowego do tablicy `messages`
3. Udostępnia metodę getera do pobierania komunikatów z tablicy `messages`
4. Wyświetla menu wyboru języka i wywołuje załadowanie ładowanie treści z pliku do tablicy walidując przy użyciu `NumericInteraction::choiceOfRange` czy dokonano prawidłowego wyboru

Teraz przeanalizujmy klasę `NumericInteraction`:

1. Sprawdza czy podany łańcuch znaków składa się tylko z cyfr
2. W sposób ciągły waliduje poprawność wyboru użytkownika i zwraca komunikaty w odpowiednim języku wykorzystując `Language::getMessage`

Na koniec został do przeanalizowania główny plik z `int main()`:
1. Tworzy instancje obiektów z klas `Language` i `NumericInteraction`
2. W sposób ciągły wykonuje kod odpowiedzialny za wyświetlenie głównego menu wyboru wykorzystując `NumericInteraction::choiceOfRange` i `NumericInteraction::choiceOfRange` oraz zgodnie z wyborem wyświetli *"Play"* albo wywoła metodę wyboru języka

Pewnie zauważyłeś że w `Language` i `main` mamy bardzo podobne metody które wyświetlają jakieś menu i po walidacji wyboru wykonują odpowiednie czynności wiec można je zawrzeć w nowej klasie np.: `GameMenu` dzieki czemu cały kod powiązany z menu bedzie znajdował się w jednym miejscu oraz `int main()` zostanie uproszczony i bedzie czytelniejszy.  
Czy to rozwiąże problem cyklicznej zależności?  
Jeszcze nie, ale jest to dobry krok ku temu. Ponieważ gdy zmodyfikujemy `NumericInteraction::choiceOfRange` aby przyjmował komunikaty do wstawienia bedziemy mogli pobrać je z `Language` w `GameMenu` i przekazać do choiceOfRange gdy to bedzie konieczne.

WOW cykliczność zależności właśnie została zerwana i nie mamy już `Spaghetti Code` a nasza nowa struktura projektu bedzie następująca:

![Spaghetti code w Tic-Tac-Toe](/Images/Fix_Spaghetti_Code.png)

#### Przejdźmy do refaktoryzacji kodu.

`NumericInteraction::choiceOfRange` bedzie wyglądał teraz tak:

```cpp
short NumericInteraction::choiceOfRange(short min, short max, std::string choiceMessage, std::string choiceErrorMessage, std::string choiceErrorConcatenationMessage)
{
	std::string choice;
	short choiceMenu = 0;
	// Ciągła walidacja wyboru:
	while (true) {
		std::cout << choiceMessage;
		std::cin >> choice;

		// Sprawdzenie poprawności wyboru:
		if (isNumber(choice)) {
			choiceMenu = std::stoi(choice);
			// !!!! UWAGA !!!! zastąpienie wartości 1 i 3 na min i max
			if (choiceMenu >= min && choiceMenu <= max) {
				break; // Wyjście z pętli gdy wybór jest poprawny i w zakresie
			}
		}
		// Wyświetlenie komunikatu o błędzie gdy oba warunki if nie są spełnione:
		std::cout << choiceErrorMessage << min << choiceErrorConcatenationMessage << max << "." << std::endl;
		// Zmieniono zapis aby wykorzystywał zmienne min i max
	}

	return choiceMenu;
}
```
Utworzymy teraz nową klasę `GameMenu` i tym razem zamiast tworzyć osobno plik nagłówkowy `.h` i implementacyjny `.cpp` zrobimy to za jednym zamachem tworząc klasę a __Visual Studio 2022__ przygotuje oba pliki za nas:


![Dodawanie nowej klasy w projekcie](/Images/NewElementClassVS.png)
![Dodawanie nowej klasy w projekcie](/Images/NewElementClassVS2.png)

Struktura nagłówka `GameMenu`:

```cpp
#pragma once
#include <iostream>
#include <string>
#include "Language.h"
#include "NumericInteraction.h"

class GameMenu
{
private:
	Language lang;
	NumericInteraction numericInter;
public:
	GameMenu();
	~GameMenu();
	void mainMenu(Language lang, NumericInteraction numericInter);
	std::string selectLanguageMenu(Language lang, NumericInteraction numericInter);
};
```

Implementacja konstruktora, destruktora i metod `GameMenu`:

```cpp
#include "GameMenu.h"

GameMenu::GameMenu()
{
	// Wywołanie metody domyślnie wyświetlającej menu główne
	mainMenu(lang, numericInter);
}

GameMenu::~GameMenu()
{
}

//
// PUBLIC METHODS
//

void GameMenu::mainMenu(Language lang, NumericInteraction numericInter)
{
	while (true)
	{
		std::string langCode = "en";
		// Menu do wyświetlenia:
		std::cout << lang.getMessage(0) + "\n\n"
			<< lang.getMessage(1) + "\n"
			<< lang.getMessage(2) + "\n"
			<< lang.getMessage(3) + "\n" << std::endl;
		// Wybór opcji z menu uzupełniony o komunikaty językowe z Language lang
		short choiceMenu = numericInter.choiceOfRange(1, 3, lang.getMessage(4), lang.getMessage(5), lang.getMessage(6));
		// Wywołanie odpowiedniego case`a w zależności od wyboru:
		switch (choiceMenu)
		{
		case 1:
			std::cout << "Play" << std::endl;
			break;
		case 2:
			// Wyświetla menu wyboru języka i przypisuje zwracany kod języka do zmiennej langCode
			langCode = selectLanguageMenu(lang, numericInter);
			// Próba wczytania pliku z komunikatami w zależności od wyboru języka i obsługa błędu
			try {
				lang.loadLanguageFile(langCode);
			}
			catch (const std::runtime_error expection) {
				std::cerr << "Error: " << expection.what() << "\n";
			}
			break;
		case 3:
			return; // Nie może być return 0; bo ta funkcja jest typu void i nie zwraca żadnej wartości, a break; nie zakończyłby pętli
		}
	}
}

std::string GameMenu::selectLanguageMenu(Language lang, NumericInteraction numericInter)
{
	std::string langCode;

	// Menu do wyświetlenia:
	std::cout << lang.getMessage(7) + "\n\n"
		<< lang.getMessage(8) + "\n"
		<< lang.getMessage(9) + "\n"
		<< lang.getMessage(10) + "\n"
		<< lang.getMessage(11) + "\n" << std::endl;
	// Wybór opcji z menu uzupełniony o komunikaty językowe z Language lang
	short choice = NumericInteraction().choiceOfRange(1, 4, lang.getMessage(4), lang.getMessage(5), lang.getMessage(6));
	// Przypisanie kodu języka w zależności od wyboru:
	switch (choice)
	{
	case 1:
		langCode = "en";
		break;
	case 2:
		langCode = "pl";
		break;
	case 3:
		langCode = "de";
		break;
	case 4:
		langCode = "ru";
		break;
	}
	// Zwrócenie kodu języka
	return langCode;
}
```



Teraz klasa `GameMenu` gdy zostanie zainstancjonowana to konstruktor domyślnie wywoła menu główne które zostało trochę zmodyfikowane.  
Metody teraz wymagają przekazania do nich instancji obiektów klas `Language` i `NumericInteraction`.

Uproszczony kod w `main`:

```cpp
#include "GameMenu.h"

int main()
{
	GameMenu gameMenu;
	return 0;
}
```

Zanim przejdziesz dalej zobacz czy wykorzystujesz w danych klasach wszystkie zadeklarowane inkludy - `#include ...`

## Ulepszenia renderowania treści w konsoli CMD

Pierwszy etap prac mamy już za sobą. Przygotowaliśmy program z menu który pozwala na zmianę języka.  
Aktualnie każde wypisanie treści przy pomocy `std::cout` jest dopisywane, a my bedziemy chcieli aby zastepowało poprzedni render czyli czyściło zawartość konsoli i dopiero wypisywało nową treść. Wykorzystamy do tego bibliotekę `<Windows.h>` i dopiszemy odpowiednią metodę odpowiedzialną za ten proceder w NumericInteraction
