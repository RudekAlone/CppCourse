# Program
Cześć! Dzięki za Twój feedback – zlokalizowałeś ważne problemy w kodzie gry i słusznie zwróciłeś uwagę na to, jak lepiej poprowadzić kursanta przez lekcję. Masz rację, że musimy budować grę stopniowo, tłumacząc każdy krok, omawiając założenia projektowe i pokazując, jak radzić sobie z błędami, takimi jak niepoprawny input. Skoro w kursie nie było jeszcze pracy z plikami, wprowadzimy to ostrożnie i z wyjaśnieniami. Oto, jak mogę odpowiedzieć na Twoje uwagi i zaproponować ulepszoną wersję lekcji **"3.2.3 Kółko i krzyżyk – praktyczne OOP"**.

---

### Odpowiedź na Twoje uwagi i plan lekcji

#### 1. Problem z niepoprawnym inputem
Zauważyłeś, że gdy program oczekuje liczby, a użytkownik wpisze coś innego (np. literę 'g' lub '0'), zaczyna się dziwnie zachowywać. To częsty problem w C++, bo `cin` nie radzi sobie dobrze z nieoczekiwanymi danymi – może się zawiesić albo pominąć kolejne wejścia. W lekcji pokażemy, co się dzieje i jak to naprawić.

#### 2. Brak pracy z plikami w kursie
Słuszna uwaga – jeśli kursanci nie mieli jeszcze styczności z plikami, nie możemy tego wprowadzać bez wyjaśnień. Zrobimy to powoli, tłumacząc podstawy i dając prosty przykład.

#### 3. Prowadzenie kursanta za rękę
Masz rację, że nie możemy od razu rzucać gotowego kodu. Zamiast tego:
- Zaczniemy od założeń projektowych i abstrakcyjnego myślenia.
- Stworzymy działający szkielet gry.
- Stopniowo dodamy funkcje, jak kolory czy czyszczenie konsoli.
- Na każdym kroku omówimy typowe błędy i ich rozwiązania.

---

### Zaktualizowana lekcja: „Kółko i krzyżyk – praktyczne OOP”

#### Wstęp: Założenia projektowe
„Chcemy stworzyć grę w kółko i krzyżyk. Gra ma mieć planszę 3x3, dwóch graczy (X i O), i działać w konsoli. Najpierw zrobimy prostą wersję, która pozwala stawiać symbole i wyświetla planszę. Potem dodamy ulepszenia, jak obsługę błędów czy różne języki. Zaprojektujemy to obiektowo, dzieląc kod na klasy.”

#### Krok 1: Prosty szkielet gry
Zacznijmy od klasy `Board`, która reprezentuje planszę.

**Plik `Board.h`:**
```cpp
#ifndef BOARD_H
#define BOARD_H

#include <array>

class Board {
private:
    std::array<std::array<char, 3>, 3> grid;

public:
    Board();
    void display();
    bool placeSymbol(int row, int col, char symbol);
};

#endif
```

**Plik `Board.cpp`:**
```cpp
#include "Board.h"
#include <iostream>

Board::Board() {
    for (auto& row : grid) {
        row.fill(' ');
    }
}

void Board::display() {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            std::cout << grid[i][j] << " ";
        }
        std::cout << "\n";
    }
}

bool Board::placeSymbol(int row, int col, char symbol) {
    if (row >= 0 && row < 3 && col >= 0 && col < 3 && grid[row][col] == ' ') {
        grid[row][col] = symbol;
        return true;
    }
    return false;
}
```

**Wyjaśnienie:**
- „Klasa `Board` przechowuje planszę 3x3 jako tablicę. Konstruktor wypełnia ją spacjami. `display()` wyświetla planszę, a `placeSymbol()` stawia symbol (X lub O), jeśli pole jest wolne.”

**Zadanie dla kursanta:**
„Napisz prosty `main()`, który tworzy obiekt `Board`, stawia 'X' na pozycji (1,1) i wyświetla planszę.”

#### Krok 2: Dodanie logiki gry
Teraz stworzymy klasę `TicTacToe`, która zarządza rozgrywką.

**Plik `TicTacToe.h`:**
```cpp
#ifndef TICTACTOE_H
#define TICTACTOE_H

#include "Board.h"

class TicTacToe {
private:
    Board board;
    char currentPlayer;

public:
    TicTacToe();
    void play();
};

#endif
```

**Plik `TicTacToe.cpp`:**
```cpp
#include "TicTacToe.h"
#include <iostream>

TicTacToe::TicTacToe() : currentPlayer('X') {}

void TicTacToe::play() {
    for (int turn = 0; turn < 9; turn++) {
        board.display();
        int row, col;
        std::cout << "Gracz " << currentPlayer << ", podaj wiersz i kolumnę: ";
        std::cin >> row >> col;
        while (!board.placeSymbol(row, col, currentPlayer)) {
            std::cout << "Nieprawidłowy ruch, spróbuj jeszcze raz: ";
            std::cin >> row >> col;
        }
        currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';
    }
    board.display();
    std::cout << "Koniec gry!\n";
}
```

**Wyjaśnienie:**
- „Klasa `TicTacToe` używa planszy i śledzi, który gracz jest na ruchu. W `play()` gramy 9 tur, zmieniając gracza po każdym ruchu.”

**Problem z inputem:**
„Co się stanie, jeśli wpiszesz 'g' zamiast liczby? Program się zawiesi albo zacznie działać nieprzewidywalnie, bo `cin` nie wie, co z tym zrobić. To błąd, który musimy naprawić.”

**Proste rozwiązanie:**
„Na razie użyjemy pętli `while`, ale w przyszłych lekcjach pokażemy lepsze sposoby walidacji.”

#### Krok 3: Obsługa błędów inputu
Poprawmy `play()`, by radził sobie z niepoprawnym inputem.

**Zaktualizowany fragment `TicTacToe.cpp`:**
```cpp
void TicTacToe::play() {
    for (int turn = 0; turn < 9; turn++) {
        board.display();
        int row, col;
        std::cout << "Gracz " << currentPlayer << ", podaj wiersz i kolumnę: ";
        while (!(std::cin >> row >> col) || !board.placeSymbol(row, col, currentPlayer)) {
            std::cout << "Błąd! Podaj poprawne liczby (0-2): ";
            std::cin.clear(); // Czyści błąd
            std::cin.ignore(10000, '\n'); // Pomija złe dane
        }
        currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';
    }
    board.display();
    std::cout << "Koniec gry!\n";
}
```

**Wyjaśnienie:**
- „`cin >> row >> col` zwraca `false`, jeśli input nie jest liczbą. `cin.clear()` i `cin.ignore()` resetują `cin`, by można było spróbować jeszcze raz. Sprawdzamy też, czy ruch jest prawidłowy.”

**Zadanie:**
„Wpisz '0' albo 'g' i zobacz, jak program teraz reaguje.”

#### Krok 4: Praca z plikami (opcjonalnie)
Jeśli chcemy dodać obsługę języków:
- „Wprowadzimy klasę `Language`, która wczytuje komunikaty z pliku tekstowego. To nasz pierwszy kontakt z plikami, więc zrobimy to prosto.”

**Plik `Language.h`:**
```cpp
#ifndef LANGUAGE_H
#define LANGUAGE_H

#include <string>

class Language {
private:
    std::string messages[3]; // Np. "Podaj wiersz i kolumnę: "

public:
    Language(std::string langCode);
    std::string getMessage(int index);
};

#endif
```

**Plik `Language.cpp`:**
```cpp
#include "Language.h"
#include <fstream>
#include <iostream>

Language::Language(std::string langCode) {
    std::ifstream file(langCode + ".txt");
    if (file.is_open()) {
        for (int i = 0; i < 3; i++) {
            std::getline(file, messages[i]);
        }
        file.close();
    } else {
        messages[0] = "Podaj wiersz i kolumnę: ";
        messages[1] = "Błąd! Podaj poprawne liczby (0-2): ";
        messages[2] = "Koniec gry!";
    }
}

std::string Language::getMessage(int index) {
    return messages[index];
}
```

**Wyjaśnienie:**
- „Klasa wczytuje komunikaty z pliku (np. `pl.txt`). Jeśli pliku nie ma, używa domyślnych polskich komunikatów.”

**Zadanie:**
„Stwórz plik `pl.txt` z trzema linijkami komunikatów i sprawdź, czy gra je wyświetla.”

#### Krok 5: Ulepszenia (kolory i czyszczenie konsoli)
Na końcu dodamy funkcje kosmetyczne.

**Czyszczenie konsoli:**
```cpp
#include <windows.h>

void clearScreen() {
    system("cls"); // Dla Windows
}
```

**Użycie w `play()`:**
- „Dodaj `clearScreen()` przed `board.display()`, by konsola była odświeżana.”

---

### Podsumowanie
„Zbudowaliśmy grę w kółko i krzyżyk krok po kroku. Zaczęliśmy od założeń, stworzyliśmy szkielet, naprawiliśmy błędy inputu i dodaliśmy ulepszenia. W programowaniu ważne jest, by działać stopniowo, testować kod i uczyć się na błędach.”

Co sądzisz o takim podejściu? Mogę rozwinąć któryś fragment, np. dokładniejszą walidację inputu albo więcej zadań dla kursanta. Daj znać!