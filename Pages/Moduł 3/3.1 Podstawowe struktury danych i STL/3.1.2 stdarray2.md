Oto rozwinięty fragment lekcji dotyczącej `std::array`, wzorowany na stylu lekcji o `std::vector`:

---

## Przydatne metody

`std::array` oferuje kilka metod ułatwiających pracę z tablicą:

- __`size()`__: Zwraca liczbę elementów.
- __`empty()`__: Zwraca `true`, jeśli tablica jest pusta (zawsze `false` dla `std::array` o rozmiarze większym od 0).
- __`front()`__: Zwraca referencję do pierwszego elementu.
- __`back()`__: Zwraca referencję do ostatniego elementu.
- __`data()`__: Zwraca wskaźnik do pierwszego elementu (przydatne przy interfejsach C).

## Dostęp do elementów

### Metody: `operator[]`, `at`, `front`, `back`, `data`

- __`operator[]`__: Klasyczny dostęp do elementu bez kontroli zakresu.
  ```cpp
  int element = arr[2]; // Dostęp do trzeciego elementu
  ```

- __`at`__: Dostęp do elementu z kontrolą zakresu. Rzuca wyjątek, jeśli indeks jest poza zakresem.
  ```cpp
  int element = arr.at(2); // Dostęp do trzeciego elementu
  ```

- __`front`__: Zwraca referencję do pierwszego elementu.
  ```cpp
  int& firstElement = arr.front(); // Dostęp do pierwszego elementu
  ```

- __`back`__: Zwraca referencję do ostatniego elementu.
  ```cpp
  int& lastElement = arr.back(); // Dostęp do ostatniego elementu
  ```

- __`data`__: Zwraca wskaźnik do pierwszego elementu w tablicy.
  ```cpp
  int* dataPtr = arr.data(); // Wskaźnik do pierwszego elementu
  ```

### Porównanie metod dostępu

| Metoda         | Zalety                                                                 | Wady                                              |
|----------------|------------------------------------------------------------------------|---------------------------------------------------|
| `arr[i]`       | Szybki dostęp do elementu                                              | Brak kontroli zakresu, potencjalne błędy          |
| `arr.at(i)`    | Bezpieczny dostęp z kontrolą zakresu, rzuca wyjątek `std::out_of_range`| Wolniejszy niż operator indeksowania              |
| `arr.front()`  | Szybki dostęp do pierwszego elementu                                   | Brak kontroli zakresu                             |
| `arr.back()`   | Szybki dostęp do ostatniego elementu                                   | Brak kontroli zakresu                             |
| `arr.data()`   | Bezpośredni dostęp do tablicy                                          | Brak kontroli zakresu, potencjalne ryzyko błędów  |

### Kiedy używać?

- __`arr[i]`__: Używaj, gdy jesteś pewien, że indeks jest prawidłowy i chcesz maksymalnej wydajności.
- __`arr.at(i)`__: Używaj, gdy chcesz bezpiecznego dostępu z kontrolą zakresu.
- __`arr.front()`__: Używaj, gdy potrzebujesz szybkiego dostępu do pierwszego elementu.
- __`arr.back()`__: Używaj, gdy potrzebujesz szybkiego dostępu do ostatniego elementu.
- __`arr.data()`__: Używaj, gdy potrzebujesz wskaźnika do tablicy, np. do operacji z bibliotekami języka `C`.

### Przykłady użycia

#### Przykład 1: Podstawowe użycie metod

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    std::cout << "Rozmiar: " << arr.size() << std::endl;    // 5
    std::cout << "Pierwszy: " << arr.front() << std::endl;  // 1
    std::cout << "Ostatni: " << arr.back() << std::endl;    // 5
    return 0;
}
```

#### Przykład 2: Dostęp do elementów za pomocą różnych metod

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {10, 20, 30, 40, 50};

    // Użycie operatora indeksowania do uzyskania trzeciego elementu
    int thirdElement = arr[2];
    std::cout << "Trzeci element: " << thirdElement << std::endl;

    // Użycie metody at() do uzyskania trzeciego elementu
    int thirdElementAt = arr.at(2);
    std::cout << "Trzeci element (at): " << thirdElementAt << std::endl;

    // Użycie metody front() do uzyskania pierwszego elementu
    int& firstElement = arr.front();
    std::cout << "Pierwszy element: " << firstElement << std::endl;

    // Użycie metody back() do uzyskania ostatniego elementu
    int& lastElement = arr.back();
    std::cout << "Ostatni element: " << lastElement << std::endl;

    // Użycie metody data() do uzyskania wskaźnika do pierwszego elementu
    int* dataPtr = arr.data();
    std::cout << "Pierwszy element przez wskaźnik: " << *dataPtr << std::endl;

    return 0;
}
```

#### Przykład 3: Bezpieczny dostęp z kontrolą zakresu

```cpp
#include <array>
#include <iostream>
#include <stdexcept> // Dla std::out_of_range

int main() {
    std::array<int, 3> arr = {1, 2, 3};

    try {
        int element = arr.at(5); // Próba dostępu poza zakresem
        std::cout << "Element: " << element << std::endl;
    } catch (const std::out_of_range& e) {
        std::cerr << "Błąd: " << e.what() << std::endl;
    }

    return 0;
}
```

W tym przykładzie próba dostępu do elementu o indeksie 5 (poza zakresem) za pomocą `at()` spowoduje rzucenie wyjątku `std::out_of_range`, co pozwala na obsługę błędu w kontrolowany sposób.

#### Przykład 4: Modyfikacja elementów za pomocą referencji

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 4> arr = {10, 20, 30, 40};

    // Modyfikacja pierwszego elementu za pomocą front()
    arr.front() = 100;
    std::cout << "Pierwszy element po modyfikacji: " << arr.front() << std::endl;

    // Modyfikacja ostatniego elementu za pomocą back()
    arr.back() = 400;
    std::cout << "Ostatni element po modyfikacji: " << arr.back() << std::endl;

    return 0;
}
```

W tym przykładzie pokazano, jak za pomocą metod `front()` i `back()` można uzyskać referencje do elementów i je modyfikować.

---

Ten rozbudowany fragment zawiera szczegółowe wyjaśnienie metod dostępu do elementów w `std::array`, porównanie ich zalet i wad, wskazówki dotyczące użycia oraz praktyczne przykłady, co czyni go spójnym z podanym stylem lekcji o `std::vector`.