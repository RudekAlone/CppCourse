# 3.1.2 std::array

#### Wstęp
`std::array` to kontener wprowadzony w C++11, który reprezentuje tablicę o stałym rozmiarze. Jest częścią biblioteki standardowej C++ (STL) i oferuje wiele zalet w porównaniu do klasycznych tablic C.

#### Definicja i Inicjalizacja
`std::array` jest szablonem klasy, który wymaga dwóch parametrów: typu elementów oraz liczby elementów. Oto przykład definicji i inicjalizacji `std::array`:

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};

    for (const auto& elem : arr) {
        std::cout << elem << " ";
    }

    return 0;
}
```

#### Zalety `std::array`
1. **Bezpieczeństwo**: `std::array` zapewnia lepsze bezpieczeństwo typów i zapobiega błędom związanym z przekroczeniem zakresu tablicy.
2. **Integracja z STL**: `std::array` współpracuje z algorytmami STL, co umożliwia łatwe sortowanie, wyszukiwanie i manipulację danymi.
3. **Stały rozmiar**: Rozmiar `std::array` jest znany w czasie kompilacji, co pozwala na optymalizacje kompilatora.

#### Metody `std::array`
`std::array` oferuje wiele przydatnych metod, takich jak:
- `at(size_t index)`: Zwraca referencję do elementu na podanym indeksie z kontrolą zakresu.
- `size()`: Zwraca liczbę elementów w tablicy.
- `front()`: Zwraca referencję do pierwszego elementu.
- `back()`: Zwraca referencję do ostatniego elementu.
- `data()`: Zwraca wskaźnik do pierwszego elementu tablicy.

Przykład użycia metod:

```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};

    std::cout << "First element: " << arr.front() << std::endl;
    std::cout << "Last element: " << arr.back() << std::endl;
    std::cout << "Element at index 2: " << arr.at(2) << std::endl;

    return 0;
}
```

#### Porównanie z klasycznymi tablicami
- **Bezpieczeństwo**: Klasyczne tablice nie oferują kontroli zakresu, co może prowadzić do błędów. `std::array` zapewnia kontrolę zakresu za pomocą metody `at()`.
- **Funkcjonalność**: Klasyczne tablice nie mają metod członkowskich, podczas gdy `std::array` oferuje wiele przydatnych metod.
- **Rozmiar**: Rozmiar klasycznych tablic musi być określony w czasie kompilacji, podobnie jak w przypadku `std::array`. Jednak `std::array` jest bardziej elastyczna dzięki integracji z STL.

#### Podsumowanie
`std::array` to potężne narzędzie, które łączy zalety klasycznych tablic z funkcjonalnością i bezpieczeństwem oferowanym przez STL. Jest to doskonały wybór, gdy potrzebujemy tablicy o stałym rozmiarze i chcemy korzystać z zaawansowanych funkcji biblioteki standardowej C++.

Czy chciałbyś dodać coś jeszcze do tej lekcji?


# GROK AI

### Kluczowe punkty
- `std::array` to bezpieczna i funkcjonalna alternatywa dla tablic C-style w C++, szczególnie przydatna w programowaniu gier w Unreal Engine 5.
- Zapewnia stały rozmiar, sprawdzanie granic i integrację ze standardową biblioteką C++.
- Porównanie z tablicami C-style obejmuje zalety, takie jak brak degradacji do wskaźnika i łatwiejsze zarządzanie rozmiarem.

### Wprowadzenie do `std::array`
`std::array` to kontener z biblioteki STL, który przechowuje tablicę o stałym rozmiarze. Jest to ulepszenie tablic C-style, oferując dodatkowe funkcje, takie jak sprawdzanie granic i dostęp do rozmiaru bez dodatkowych obliczeń. W kontekście tworzenia gier w Unreal Engine 5, `std::array` jest przydatny do zarządzania danymi o znanym rozmiarze, na przykład do przechowywania współrzędnych czy stanów gry.

### Deklaracja i inicjalizacja
Aby użyć `std::array`, należy dołączyć nagłówek `<array>`. Deklaracja wygląda następująco:
- `std::array<T, N> nazwa;` gdzie `T` to typ elementów, a `N` to liczba elementów (stała w czasie kompilacji).

Przykłady inicjalizacji:
- Domyślna: `std::array<int, 3> arr;` (elementy mają wartości nieokreślone dla typów podstawowych).
- Agregatowa: `std::array<int, 3> arr = {1, 2, 3};` (wszystkie elementy są inicjowane).
- Wartościowa: `std::array<int, 3> arr = {};` (elementy typu podstawowego są zerowane).

**Uwaga:** Inicjalizacja z mniejszą liczbą elementów może prowadzić do wartości nieokreślonych, więc zaleca się zawsze inicjować wszystkie elementy.

### Dostęp do elementów i funkcje
Dostęp do elementów można uzyskać za pomocą:
- Operatora `[]`: `arr[index]` (bez sprawdzania granic, niebezpieczne przy błędach).
- Metody `at()`: `arr.at(index)` (sprawdza granice, rzuca wyjątek przy przekroczeniu).

Funkcje członkowskie obejmują:
- `size()`: zwraca liczbę elementów.
- `empty()`: zwraca `true`, jeśli tablica jest pusta.
- `front()` i `back()`: dostęp do pierwszego i ostatniego elementu.
- `data()`: zwraca wskaźnik do pierwszego elementu.

Przykład użycia iteratorów:
```cpp
for (auto it = arr.begin(); it != arr.end(); ++it) {
    std::cout << *it << " ";
}
```

### Porównanie z tablicami C-style
Tablice C-style mają ograniczenia, takie jak brak informacji o rozmiarze i degradacja do wskaźnika, co może prowadzić do błędów. `std::array` oferuje:
- Znajomość własnego rozmiaru.
- Sprawdzanie granic za pomocą `at()`.
- Lepsza integracja z algorytmami STL.

Tabela porównawcza:

| Funkcja                  | `std::array`                     | Tablica C-style          |
|--------------------------|-----------------------------------|--------------------------|
| Rozmiar                  | Znany, dostępny przez `size()`   | Nieznany, wymaga obliczeń |
| Sprawdzanie granic       | Tak, przez `at()`                | Nie, niebezpieczne       |
| Degradacja do wskaźnika  | Nie                              | Tak, traci informacje    |
| Integracja ze STL        | Tak, łatwa współpraca            | Ograniczona              |

### Ćwiczenia
1. Zadeklaruj i zainicjuj `std::array` z trzema liczbami całkowitymi: 1, 2, 3, a następnie wypisz elementy.
2. Napisz funkcję, która przyjmuje `std::array` liczb zmiennoprzecinkowych i wypisuje jego rozmiar oraz elementy.
3. Stwórz funkcję sprawdzającą, czy `std::array` znaków jest palindromem.
4. Użyj `std::fill`, aby wypełnić `std::array` konkretną wartością i wypisz wynik.

---

### Notatka szczegółowa

#### Wprowadzenie i kontekst
W ramach kursu dla nowych adeptów programowania w C++ i tworzenia gier w Unreal Engine 5, lekcja 3.1.2 koncentruje się na `std::array`, kontenerze STL, który jest alternatywą dla tablic C-style. Grupa odbiorców, w wieku od 15 do 30 lat, wymaga przystępnego wyjaśnienia, uwzględniającego praktyczne zastosowania, szczególnie w kontekście gier. Analiza obejmuje szczegółowe porównanie z tablicami C-style, co jest kluczowe, biorąc pod uwagę wcześniejsze lekcje (3.1.1 Tablice - Array).

#### Szczegółowe omówienie `std::array`
`std::array` jest zdefiniowany w nagłówku `<array>` i działa jako szablon `<class T, std::size_t N> struct array;`, dostępny od C++11. Jest to kontener agregatowy, co oznacza, że można go inicjować za pomocą inicjalizacji agregatowej, np. `std::array<int, 3> a = {1, 2, 3};`. Nie degraduje się do wskaźnika, co odróżnia go od tablic C-style i zapobiega utracie informacji o rozmiarze.

Zalety `std::array` obejmują:
- Spełnianie wymagań kontenera STL, takich jak [Container](https://en.cppreference.com/w/cpp/named_req/Container), [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer), i od C++17 [ContiguousContainer](https://en.cppreference.com/w/cpp/named_req/ContiguousContainer).
- Iteratory nigdy nie są unieważniane, co zapewnia stabilność podczas operacji, choć podczas wymiany (`swap`) wskazują na te same elementy, zmieniając ich wartości.
- Specjalne przypadki, takie jak tablice o zerowym rozmiarze (N=0), gdzie `begin() == end()`, a wywołanie `front()` lub `back()` jest nieokreślone.

#### Deklaracja i inicjalizacja w szczegółach
Deklaracja wymaga podania typu `T` i stałego rozmiaru `N`. Inicjalizacja może być:
- Domyślna: `std::array<int, 3> arr;`, co dla typów podstawowych oznacza wartości nieokreślone.
- Agregatowa: `std::array<int, 3> arr = {1, 2, 3};`, gdzie podanie mniejszej liczby inicjalizatorów prowadzi do domyślnej inicjalizacji pozostałych elementów, co dla typów podstawowych oznacza wartości nieokreślone, co może być źródłem błędów. Zaleca się unikanie tego, stosując inicjalizację wartościową, np. `std::array<int, 3> arr = {};`, co zeruje elementy dla typów podstawowych.

#### Dostęp do elementów i funkcje członkowskie
Dostęp do elementów:
- Operator `[]`: `arr[index]`, bez sprawdzania granic, co może prowadzić do nieokreślonego zachowania przy błędach.
- Metoda `at()`: `arr.at(index)`, z sprawdzaniem granic, rzucająca `std::out_of_range` przy przekroczeniu.

Funkcje członkowskie:
- `size()`: Zwraca `std::size_t`, liczbę elementów.
- `empty()`: Zwraca `true`, jeśli rozmiar to 0.
- `front()` i `back()`: Dostęp do pierwszego i ostatniego elementu.
- `data()`: Zwraca wskaźnik do pierwszego elementu, przydatny w interfejsach niskopoziomowych.
- Brak funkcji `fill` jako członkowskiej; zamiast tego używa się `std::fill` z `<algorithm>`, np. `std::fill(arr.begin(), arr.end(), 5);`.

#### Iteratory i algorytmy
`std::array` obsługuje iteratory losowego dostępu, takie jak `begin()`, `end()`, `rbegin()`, `rend()`, co pozwala na użycie pętli for-based lub range-based, np.:
```cpp
for (auto it = arr.begin(); it != arr.end(); ++it) {
    std::cout << *it << " ";
}
```
Lub:
```cpp
for (int elem : arr) {
    std::cout << elem << " ";
}
```
Integracja z algorytmami STL, np. `std::sort(arr.begin(), arr.end());`, jest prosta dzięki ciągłości pamięci.

#### Porównanie z tablicami C-style
Tablice C-style, omówione w lekcji 3.1.1, mają istotne ograniczenia:
- Brak informacji o rozmiarze, wymagający obliczeń, np. `sizeof(arr)/sizeof(arr[0])`, co jest zawodne przy przekazywaniu do funkcji (degradacja do wskaźnika).
- Brak wbudowanego sprawdzania granic, co zwiększa ryzyko przepełnienia bufora.
- Mniejsza integracja ze STL, wymagająca dodatkowych zabiegów.

`std::array` rozwiązuje te problemy:
- Rozmiar dostępny przez `size()`, bez dodatkowych obliczeń.
- Sprawdzanie granic przez `at()`, zwiększające bezpieczeństwo.
- Brak degradacji do wskaźnika, co ułatwia przekazywanie do funkcji, np. przez referencję (`const std::array<int, 3>&`).

Tabela porównawcza:

| Funkcja                  | `std::array`                     | Tablica C-style          |
|--------------------------|-----------------------------------|--------------------------|
| Rozmiar                  | Znany, dostępny przez `size()`   | Nieznany, wymaga obliczeń |
| Sprawdzanie granic       | Tak, przez `at()`                | Nie, niebezpieczne       |
| Degradacja do wskaźnika  | Nie                              | Tak, traci informacje    |
| Integracja ze STL        | Tak, łatwa współpraca            | Ograniczona              |

#### Praktyczne zastosowania i ćwiczenia
W kontekście Unreal Engine 5, `std::array` jest przydatny do zarządzania stałymi zbiorami danych, np. współrzędnych gracza czy stanów gry. Ćwiczenia pomagają utrwalić wiedzę:
1. Zadeklaruj i zainicjuj `std::array<int, 3> arr = {1, 2, 3};`, wypisz elementy.
2. Napisz funkcję `void printArray(const std::array<double, 5>& arr)` wypisującą rozmiar i elementy.
3. Stwórz funkcję `bool isPalindrome(const std::array<char, 5>& arr)` sprawdzającą, czy tablica jest palindromem.
4. Użyj `std::fill` do wypełnienia `std::array<int, 4>` wartością 5 i wypisz wynik.

#### Uwagi dodatkowe
Od C++20 dostępna jest funkcja `std::to_array`, umożliwiająca tworzenie `std::array` z tablicy C-style, np. `auto arr2 = std::to_array({1, 2, 3});`, co jest zaawansowaną funkcją, możliwą do pominięcia na tym etapie. `std::array` może być również używany do tablic wielowymiarowych, np. `std::array<std::array<int, 3>, 2> multi_arr;`, ale to temat na późniejsze lekcje.

#### Cytaty kluczowe
- [std::array - cppreference.com](https://en.cppreference.com/w/cpp/container/array)
- [STD::array in C++ - GeeksforGeeks](https://www.geeksforgeeks.org/stdarray-in-cpp/)
- [C++ std::array (With Examples) - Programiz](https://www.programiz.com/cpp-programming/std-array)
- [17.1 – Introduction to std::array – Learn C++](https://www.learncpp.com/cpp-tutorial/introduction-to-stdarray/)
- [array Class (C++ Standard Library) | Microsoft Learn](https://learn.microsoft.com/en-us/cpp/standard-library/array-class-stl?view=msvc-170)