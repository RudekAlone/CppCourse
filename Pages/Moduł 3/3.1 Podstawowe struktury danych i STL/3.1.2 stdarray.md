# 3.1.2: std::array

## Wstęp

`std::array` to kontener z biblioteki standardowej `C++` (__STL__), wprowadzony w `C++11`. Reprezentuje tablicę o stałym rozmiarze, który jest ustalany w czasie kompilacji i nie może być zmieniany w trakcie działania programu. Dzięki temu jest idealny do przechowywania danych o znanej liczbie elementów, takich jak współrzędne w grze czy stany obiektów.

W porównaniu do klasycznych tablic języka `C` (*raw array*), `std::array` oferuje większe bezpieczeństwo i wygodę, a jednocześnie zachowuje wysoką wydajność, co czyni go doskonałym wyborem w krytycznych punktach wymagających maksymalnej szybkości wykonania.

### Zalety std::array

1. __Bezpieczeństwo__: `std::array` pozwala na sprawdzanie granic tablicy za pomocą metody `at()`, co zapobiega błędom typu przepełnienie bufora, które są częste przy używaniu tablic *raw array*.
2. __Integracja z STL__: Współpracuje z algorytmami STL, takimi jak `std::sort` czy `std::find`, co ułatwia manipulację danymi.
3. __Stały rozmiar__: Rozmiar znany w czasie kompilacji umożliwia optymalizacje przez kompilator, co jest kluczowe w aplikacjach o wysokich wymaganiach wydajnościowych, takich jak gry.

---

## Deklaracja i inicjalizacja

Aby użyć `std::array`, należy dołączyć bibliotekę `<array>`:

```cpp
#include <array>
```

Składnia deklaracji wygląda następująco:

```cpp
std::array<T, N> nazwa;
```

- `T` to typ przechowywanych elementów (np. `int`, `double`).
- `N` to stała liczba elementów (musi być zadeklarowana w czasie kompilacji).

### Przykłady inicjalizacji:
1. __Domyślna inicjalizacja__:
   ```cpp
   std::array<int, 3> arr; // Elementy mają wartości nieokreślone dla typów podstawowych
   ```
   Elementy typu podstawowego (np. `int`) będą miały nieokreślone wartości, co może prowadzić do błędów.

2. __Inicjalizacja agregatowa__:
   ```cpp
   std::array<int, 3> arr = {1, 2, 3}; // Wszystkie elementy są inicjowane
   ```
   Wszystkie elementy są wyraźnie zdefiniowane.

3. __Inicjalizacja wartościowa__:
   ```cpp
   std::array<int, 3> arr = {}; // Elementy typu podstawowego są zerowane
   ```
   Wszystkie elementy są zerowane (dla typów podstawowych).

<div data-hint="danger">

__Ważne__: Jeśli podasz mniej wartości w inicjalizacji agregatowej niż wynosi rozmiar tablicy, pozostałe elementy zostaną domyślnie zainicjalizowane (dla `int` będą nieokreślone). Zaleca się zawsze inicjować wszystkie elementy lub używać inicjalizacji wartościowej.

</div>

#### Przykład kodu:
```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    for (const auto& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl; // Wyświetli: 1 2 3 4 5
    return 0;
}
```

---

## Dostęp do elementów

Elementy `std::array` można odczytywać i modyfikować na dwa sposoby:

1. __Operator `[]`__:
   ```cpp
   int value = arr[0]; // Pierwszy element
   ```
   - Szybki, ale nie sprawdza granic – dostęp poza zakresem prowadzi do nieokreślonego zachowania.

2. __Metoda `at()`__:
   ```cpp
   int value = arr.at(0); // Pierwszy element
   ```
   - Bezpieczna, sprawdza granice i rzuca wyjątek `std::out_of_range`, jeśli indeks jest nieprawidłowy.

### Przykład:
```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 3> arr = {1, 2, 3};
    std::cout << arr[1] << std::endl;       // Wyświetli: 2
    std::cout << arr.at(2) << std::endl;    // Wyświetli: 3
    // arr.at(3); // Rzuci wyjątek std::out_of_range
    return 0;
}
```

---

## Przydatne metody

`std::array` oferuje kilka metod ułatwiających pracę z tablicą:

- __`size()`__: Zwraca liczbę elementów.
- __`empty()`__: Zwraca `true`, jeśli tablica jest pusta (zawsze `false` dla `std::array` o rozmiarze większym od 0).
- __`front()`__: Zwraca referencję do pierwszego elementu.
- __`back()`__: Zwraca referencję do ostatniego elementu.
- __`data()`__: Zwraca wskaźnik do pierwszego elementu (przydatne przy interfejsach C).

### Przykład użycia:
```cpp
#include <array>
#include <iostream>

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    std::cout << "Rozmiar: " << arr.size() << std::endl;    // 5
    std::cout << "Pierwszy: " << arr.front() << std::endl;  // 1
    std::cout << "Ostatni: " << arr.back() << std::endl;    // 5
    return 0;
}
```

---

## Integracja z STL

Ponieważ `std::array` jest kontenerem STL, można go używać z algorytmami standardowymi, np.:

- __Sortowanie__:
  ```cpp
  #include <algorithm>
  std::sort(arr.begin(), arr.end());
  ```

- __Iteracja za pomocą pętli zakresowej__:
  ```cpp
  for (const auto& elem : arr) {
      std::cout << elem << " ";
  }
  ```

Dzięki ciągłej pamięci (kontener typu ContiguousContainer), `std::array` działa efektywnie z algorytmami wymagającymi losowego dostępu.

---

## Porównanie z tablicami C-style

Tablice C-style (np. `int arr[5];`) mają kilka wad w porównaniu do `std::array`:

| Cecha                   | `std::array`                    | Tablica C-style          |
|-------------------------|----------------------------------|--------------------------|
| __Rozmiar__             | Dostępny przez `size()`         | Trzeba obliczać ręcznie (np. `sizeof`) |
| __Sprawdzanie granic__  | Tak, przez `at()`               | Nie, brak ochrony        |
| __Przekazywanie__       | Zachowuje typ i rozmiar         | Degraduje się do wskaźnika |
| __Metody__              | Wiele (np. `front()`, `back()`) | Brak metod               |
| __Integracja z STL__    | Pełna                           | Ograniczona              |

## Przykład przekazywania do funkcji:
- Tablica C-style:
  ```cpp
  void printArray(int arr[], int size) {
      for (int i = 0; i < size; i++) {
          std::cout << arr[i] << " ";
      }
  }
  ```

- `std::array`:
  ```cpp
  void printArray(const std::array<int, 3>& arr) {
      for (const auto& elem : arr) {
          std::cout << elem << " ";
      }
  }
  ```
`std::array` jest bezpieczniejsze i wygodniejsze, bo rozmiar jest częścią typu.

---

## Zastosowania w grach (Unreal Engine 5)

W tworzeniu gier, np. w Unreal Engine 5, `std::array` może być używane do:
- Przechowywania pozycji obiektów (np. `std::array<float, 3>` dla współrzędnych x, y, z).
- Reprezentowania siatki w grze (np. plansza o stałym rozmiarze).
- Zarządzania parametrami gry o stałej liczbie elementów.

Jego stała wielkość i brak narzutu wydajnościowego czynią go idealnym w kodzie krytycznym dla wydajności.

---

# Ćwiczenia

1. __Deklaracja i wypisanie__:
   Zadeklaruj `std::array<int, 3>` z wartościami 1, 2, 3 i wypisz elementy.

    <small>Wynik w konsoli</small>

    ```yaml
    1 2 3
    ```

<details>
<summary>Rozwiązanie</summary>

<small>main.cpp</small>

```cpp
#include <iostream> // Dołączanie biblioteki do obsługi wejścia i wyjścia
#include <array>    // Dołączanie biblioteki do obsługi tablic std::array

int main() {
    // Tworzenie tablicy std::array o rozmiarze 3 i inicjalizacja wartościami 1, 2, 3
    std::array<int, 3> arr = {1, 2, 3};

    // Iteracja przez każdy element tablicy i wypisywanie go na konsolę
    for (int elem : arr) {
        std::cout << elem << " "; // Wypisywanie elementu tablicy, oddzielonego spacją
    }
    return 0;
}
```

</details>

2. __Funkcja wypisująca__:
   Napisz funkcję `printArray`, która przyjmuje `std::array<double, 5>` i wypisuje rozmiar oraz elementy.

    <small>Wynik w konsoli</small>

    ```yaml
    Rozmiar tablicy: 5
    Elementy tablicy:
    1.1 2.2 3.3 4.4 5.5 
    ```

<details>
<summary>Rozwiązanie</summary>

<small>main.cpp</small>

```cpp
#include <iostream>
#include <array>

// Funkcja, która drukuje elementy tablicy
void printArray(std::array<double, 5> arr) {
    // Wyświetla rozmiar tablicy
    std::cout << "Rozmiar tablicy: " << arr.size() << std::endl;

    std::cout << "Elementy tablicy:" << std::endl;
    // Iterujemy przez każdy element tablicy i wypisuje go
    for (double element : arr) {
        std::cout << element << " ";
    }
    // Wyświetlamy nową linię po zakończeniu drukowania elementów
    std::cout << std::endl;
}

int main() {
    // Tworzymy tablicę o nazwie myArray i inicjalizujemy ją wartościami
    std::array<double, 5> myArray = {1.1, 2.2, 3.3, 4.4, 5.5};
    // Wywołujemy funkcję printArray, aby wyświetlić w konsoli elementy tablicy
    printArray(myArray);
    return 0;
}
```

</details>

3. __Palindrom__:
   Stwórz funkcję `bool isPalindrome(const std::array<char, 5>& arr)`, która sprawdza, czy tablica jest palindromem (np. "radar").

    <small>Wynik w konsoli</small>

    ```yaml
    myArray1 is palindrome: true
    myArray2 is palindrome: false
    ```

<details>
<summary>Rozwiązanie</summary>

<small>main.cpp</small>

```cpp
#include <array> 
#include <iostream> 

// Funkcja, która sprawdza, czy tablica jest palindromem
bool isPalindrome(std::array<char, 5> arr) {
    int n = arr.size(); // Pobieramy rozmiar tablicy
    // Iterujemy przez połowę tablicy
    for (int i = 0; i < n / 2; ++i) {
        // Sprawdzamy, czy elementy na przeciwnych końcach tablicy są różne
        if (arr[i] != arr[n - 1 - i]) {
            return false; // Jeśli są różne, tablica nie jest palindromem
        }
    }
    return true; // Jeśli wszystkie elementy są takie same, tablica jest palindromem
}

int main() {
    // Tworzymy dwie tablice do testowania funkcji
    std::array<char, 5> myArray1 = {'r', 'a', 'd', 'a', 'r'};
    std::array<char, 5> myArray2 = {'h', 'e', 'l', 'l', 'o'};
    
    // Sprawdzamy, czy myArray1 jest palindromem i drukujemy wynik
    std::cout << "myArray1 is palindrome: " << (isPalindrome(myArray1) ? "true" : "false") << std::endl;
    // Sprawdzamy, czy myArray2 jest palindromem i drukujemy wynik
    std::cout << "myArray2 is palindrome: " << (isPalindrome(myArray2) ? "true" : "false") << std::endl;
    
    return 0;
}
```

</details>


# Podsumowanie

`std::array` to nowoczesne narzędzie w C++. W przeciwieństwie do tablic z języka `C`, oferuje sprawdzanie granic, łatwy dostęp do rozmiaru i integrację z algorytmami standardowymi __STL__.  
Zachęcamy do używania `std::array` zawsze, gdy potrzebujesz tablicy o stałym rozmiarze!  
Jeśli potrzebujesz tablicy o zmiennym rozmiarze, w kolejnych lekcjach omówimy `std::vector`.